/******************************************************************************* 
at45db041b特性：
  正常操作电压为2.7~3.6V，实验中发现当电压超过4.25V后读出的状态字节为9A（正常  
的状态字节值为9D），并且读写数据均不准确，所以应当保证卡片的供电电压不超过4.25V。
SPI规范：
  Data is always clocked into the device on the rising edge of SCK a- 
   nd clocked out of the device on the falling edge of SCK.All instruction-
   s,addresses and data are transferred with the most significant bit(MSB)  
   first.            
                 2005-06-02 
修改时间：2013-04-22 任意地址任意数据的写入
*******************************************************************************/ 

#include "include.h"
#include "AT45DB041D.h"

void SPI_Init(void)
{
  P3DIR |= BIT0+BIT1+BIT2+BIT3;
  P3OUT |= BIT0+BIT1+BIT2+BIT3;
  Flash_SO_in;
  delayus(100);
}

void SPI_End(void)
{ 
  Flash_CS_H;
  P3DIR &= ~(BIT1+BIT2+BIT3);
}




/*读字节*/
unsigned char SPI_HostReadByte(void) 
{ 
  unsigned char i, rByte = 0; 
  for(i = 0; i < 8; i++)
  { 
    Flash_CLK_L; 
    Flash_CLK_H; 
    rByte <<= 1; 
    if(Flash_SO_val)
      rByte = rByte+1; 
  } 

  return rByte;   
} 

/*写字节*/
void SPI_HostWriteByte(unsigned char wByte) 
{ 
  unsigned char i; 
  for(i = 0; i < 8; i++) 
  { 
    if(wByte& 0x80) 
    {
      Flash_SI_H;
    }
    else    
    {
      Flash_SI_L;
    }
    wByte <<= 1;
    Flash_CLK_L; ;
    Flash_CLK_H; ;
  } 

} 

/*******************************************************************************
描述：  读取缓冲区的内容到指定的数组里
参数：             
   buffer  - 指定buffer ID-1、2          
   BFA   - 指定BUFFER中的起始写入地址        
   pHeader - 指定存储数据的首地址         
   len   - 指定数据的长度          
*******************************************************************************/ 
void Read_Buffer(unsigned char buffer, unsigned int BFA, unsigned char *pHeader, unsigned int len) 
{
  unsigned int i = 0; 
  
  while(i++ < 255) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    { 
      break;
    }
  } 
  
  Flash_CS_L;   
  delayus(20);
  
  switch(buffer) 
  { 
    case 1 : SPI_HostWriteByte(Read_Buffer1);//#define Write_Buffer1 0x84
      break; 
    case 2 : SPI_HostWriteByte(Read_Buffer2);////#define Write_Buffer2 0x87
      break; 
  }
  SPI_HostWriteByte(0x00);//the don't care 15bits of high eight bits
  SPI_HostWriteByte((unsigned char)(BFA >> 8));//the don't care 15bits of low seven bits and the BFA of high one bit
  SPI_HostWriteByte((unsigned char)BFA);   //the BFA of low eight bits
  SPI_HostWriteByte(0x00);       //the eight don't care bits
  for(i = 0; i < len; i++) 
  {
    pHeader[i] = SPI_HostReadByte();
  } 
  Flash_CS_H;
}

/******************************************************************************/ 
/*读取状态寄存器:           */ 
/*   -----------------------------------------------------------------------  */ 
/* | bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 | */ 
/* |--------|--------|--------|--------|--------|--------|--------|--------|  */ 
/* |RDY/BUSY| COMP |   0   |   1   |   1   |   1   |   X   |   X   | */ 
/*   -----------------------------------------------------------------------  */ 
/* bit7 - 忙标记，0为忙1为不忙。            */ 
/*   当Status Register的位0移出之后，接下来的时钟脉冲序列将使SPI器件继续  */ 
/*   将最新的状态字节送出。             */ 
/* bit6 - 标记最近一次Main Memory Page和Buffer的比较结果，0相同，1不同。  */ 
/* bit5                   */ 
/* bit4                   */ 
/* bit3                   */ 
/* bit2 - 这4位用来标记器件密度，对于AT45DB041B，这4位应该是0111，一共能标记  */ 
/*   16种不同密度的器件。             */ 
/* bit1                   */ 
/* bit0 - 这2位暂时无效               */ 
/******************************************************************************/ 
unsigned char AT45DB041B_StatusRegisterRead(void) 
{ 
  unsigned char status; 
  
  Flash_CS_L;   
  SPI_HostWriteByte(Status_Register_Read);//#define Status_Register_Read 0xd7//写入读取AT45DB041B状态寄存器命令'0xd7' 
  status = SPI_HostReadByte(); 
  Flash_CS_H;
  return status;   
}
 
/******************************************************************************
描述：  主存储区连续读              
参数：             
   PA  - 页地址，0~2047          
   BFA   - 指定BUFFER中的起始写入地址        
   pHeader - 指定数据的首地址         
   len   - 指定数据的长度          
******************************************************************************/ 
void AT45DB041B_ContinuousArrayRead(unsigned int PA, unsigned int BFA, unsigned char *pHeader, unsigned int len) 
{   
  unsigned int i = 0;  
  
  while(i++ < 255) //i++ < 255用来延时等待AT...空闲
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) //读取状态寄存器最高位,判断是否为忙
    {
      break;                   //为1表示空闲则跳出
    }
  } 
  Flash_CS_L;   
  SPI_HostWriteByte(Continuous_Array_Read);//#define Continuous_Array_Read 0xe8//连续的数组读取   
  SPI_HostWriteByte((unsigned char)(PA >> 7));//此处代码很妙啊,PA >> 7则是发送PA的高4位以及最开始的4位无关紧要位   
  SPI_HostWriteByte((unsigned char)((PA << 1) | (BFA >> 8)));//因为PA有2个字节共16位,但是PA只用到了第1位到11位,
  SPI_HostWriteByte((unsigned char)BFA);//PA左移一位再或上BFA >> 8则是发送PA的低7位和BFA最高位,最后再发送BFA的低8位
  for(i = 0; i < 4; i++) 
  {
    SPI_HostWriteByte(0x00);
  } 
  for(i = 0; i < len; i++) 
  {
    pHeader[i] = SPI_HostReadByte();
    //delayus(20);
  } 
  Flash_CS_H; 
}

/*******************************************************************************
描述：
   主存储区页读.
参数：             
   PA   - 页地址，0~2047          
   BFA   - 指定BUFFER中的起始写入地址        
   pHeader - 指定数据的首地址         
   len   - 指定数据的长度          
******************************************************************************/
void AT45DB041B_MainMemoryPageRead(unsigned int PA, unsigned int BFA, unsigned char *pHeader, unsigned int len) 
{   
  unsigned int i = 0;
  
  while(i++ < 255) //i++ < 255用来延时等待AT...空闲
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) //读取状态寄存器最高位,判断是否为忙
    {
      break;                                    //为1表示空闲则跳出
    }
  } 
  Flash_CS_L;   
  SPI_HostWriteByte(Main_Memory_Page_Read);//#define Continuous_Array_Read 0xe8//连续的数组读取   
  SPI_HostWriteByte((unsigned char)(PA >> 7));//此处代码很妙啊,PA >> 7则是发送PA的高4位以及最开始的4位无关紧要位   
  SPI_HostWriteByte((unsigned char)((PA << 1) | (BFA >> 8)));//因为PA有2个字节共16位,但是PA只用到了第1位到11位,
  SPI_HostWriteByte((unsigned char)BFA);//PA左移一位再或上BFA >> 8则是发送PA的低7位和BFA最高位,最后再发送BFA的低8位
  for(i = 0; i < 4; i++) 
  {
    SPI_HostWriteByte(0x00);//发送32位无关紧要的数据
  } 
  for(i = 0; i < len; i++) 
  {
    pHeader[i] = SPI_HostReadByte();
  } 
  Flash_CS_H; 
} 

/****************************************************************************** 
描述： 
  将指定数据写入从某个地址（0~263）开始的BUFFER中。    
参数：            
   buffer - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2    
  在该指令序列中，操作码84H选择BUFFER 1，87H选择BUFFER 2   
   BFA   - BUFFER中的起始地址，0~263       
   pHeader - 待存数据的头指针        
   len   - 待存数据的长度1~264        
******************************************************************************/ 
void AT45DB041B_BufferWrite(unsigned char buffer, unsigned int BFA, unsigned char *pHeader, unsigned int len) 
{ 
  unsigned int i = 0; 
  
  while(i++ < 255) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    { 
      break;
    }
  }  
  Flash_CS_L; 
  switch(buffer) 
  { 
    case 1 : SPI_HostWriteByte(Write_Buffer1);//#define Write_Buffer1 0x84
      break; 
    case 2 : SPI_HostWriteByte(Write_Buffer2);//#define Write_Buffer2 0x87
      break; 
  } 
  SPI_HostWriteByte(0x00); 
  SPI_HostWriteByte((unsigned char)(BFA >> 8)); 
  SPI_HostWriteByte((unsigned char)BFA);  
  for(i = 0; i < len; i++) 
  {
    SPI_HostWriteByte(pHeader[i]);//delayus(20);
  } 
  Flash_CS_H; delayus(20);  
} 

/****************************************************************************** 
描述：             
   将指定数据写入从某个地址（0~263）开始的页中：包含3个动作，首先将某指定页的数据读到
   到BUFFER 1或者BUFFER 2中，再将指定数据 
   写入到BUFFER 1或者BUFFER 2中，其中可以指定BUFFER中的起始写入地址，此写入 
   动作不影响BUFFER中其它地址中的数据，然后再将BUFFER中的整个数据写入到某指 
   定页中(带预擦除)。          
参数：            
   buffer - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2    
   PA   - 页地址，0~2047          
   BFA   - 指定BUFFER中的起始写入地址        
   pHeader - 指定数据的首地址         
   len   - 指定数据的长度         
******************************************************************************/ 
void Save_data_to_Flash_inErase(unsigned char buffer, unsigned int PA, unsigned int BFA, unsigned char *pHeader, unsigned int len) 
{ 
  unsigned int i = 0; 
  
  /*2013-04-22 22:46:18添加该语句，原函数在任意写入数据时有错误，修改后测试任意页任意地址写入正常*/
  Flash_to_buffer(buffer,PA);   //读取整页数据到缓存
  
  AT45DB041B_BufferWrite(buffer, BFA, pHeader, len); //改变缓存内容
  
  while(i++ < 1000) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    {
      break;
    }
  }  
  Flash_CS_L;  
  switch(buffer)
  { 
    case 1 : SPI_HostWriteByte(Buffer1_To_MainMemory_PageProgram_WithBuilt_inErase);//#define Buffer1_To_MainMemory_PageProgram_WithBuilt_inErase x083
      break; 
    case 2 : SPI_HostWriteByte(Buffer2_To_MainMemory_PageProgram_WithBuilt_inErase);//#define Buffer2_To_MainMemory_PageProgram_WithBuilt_inErase x086
      break; 
  } 
  SPI_HostWriteByte((unsigned char)(PA >> 7)); 
  SPI_HostWriteByte((unsigned char)(PA << 1)); 
  SPI_HostWriteByte(0x00);  
  Flash_CS_H;
} 

/****************************************************************************** 
描述：            
   与上一个函数的唯一区别是不带预擦除。        
******************************************************************************/ 
void AT45DB041B_BufferToMainMemoryPageProgramWithoutBuilt_inErase(unsigned char buffer, unsigned int PA, unsigned int BFA, unsigned char *pHeader, unsigned int len)
{ 
  unsigned int i = 0; 
  
  AT45DB041B_BufferWrite(buffer, BFA, pHeader, len); 
  
  while(i++ < 1000) 
  { 
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    {
      break;
    }
  } 
  Flash_CS_L; 
  SPI_HostWriteByte(0x87 + buffer);//当buffer=1,则写入0x88命令.当buffer=2则写入0x89命令,效果和下面注释代码功能一样 
  /*switch(buffer){ 
  case 1 : SPI_HostWriteByte(Buffer1_To_MainMemory_PageProgram_WithoutBuilt_inErase);//#define Buffer1_To_MainMemory_PageProgram_WithoutBuilt_inErase x088
    break; 
  case 2 : SPI_HostWriteByte(Buffer2_To_MainMemory_PageProgram_WithoutBuilt_inErase);//#define Buffer2_To_MainMemory_PageProgram_WithoutBuilt_inErase x089
    break; 
  }*/ 
  SPI_HostWriteByte((unsigned char)(PA >> 7)); 
  SPI_HostWriteByte((unsigned char)(PA << 1)); 
  SPI_HostWriteByte(0x00); 
  for(i = 0; i < len; i++) 
  {
    SPI_HostWriteByte(pHeader[i]);delayus(20);
  } 
  Flash_CS_H; 
} 

/****************************************************************************** 
描述：             
  When a low-to-high transition occurs on the /C/S pin,the part will erase the
   selected page to 1s.The erase operation is internally self-timed and should
   take place in a maximum time of tPE.During this time,the status register will
   indicate that the part is busy.         
参数：                 
   PA   - 页地址，0~2047                  
******************************************************************************/
void AT45DB041B_PageErase(unsigned int PA) 
{
  unsigned int i = 0; 
  
  while(i++ < 255) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    { 
      break;
    }
  } 
  Flash_CS_L;  
  SPI_HostWriteByte(Page_Erase);
  SPI_HostWriteByte((unsigned char)(PA >> 7));//页地址高4位和4为无关位
  SPI_HostWriteByte((unsigned char)(PA << 1));//页地址低7位和1位无关位
  SPI_HostWriteByte(0x00);//8位无关位
  Flash_CS_H;
  while(!(AT45DB041B_StatusRegisterRead() & 0x80));//等待擦除完毕
}

/****************************************************************************** 
描述：             
  When a low-to-high transition occurs on the /C/S pin,the part will erase the
   selected block of eight pages to 1s.The erase operation is internally self-t-
  imed and should take place in a maximum time of tBE.During this time,the sta-
  tus register will indicate that the part is busy.         
参数：                 
   BLKA   - 块地址，0~255                  
******************************************************************************/
void AT45DB041B_BlockErase(unsigned char BLKA) 
{
  unsigned int i = 0; 
  
  while(i++ < 255) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    { 
      break;
    }
  } 
  Flash_CS_L;  
  SPI_HostWriteByte(Block_Erase);
  SPI_HostWriteByte((unsigned char)(BLKA >> 4));//块地址高4位和4为无关位
  SPI_HostWriteByte((unsigned char)(BLKA << 4));//块地址低4位和4位无关位
  SPI_HostWriteByte(0x00);//8位无关位
  Flash_CS_H;
  while(!(AT45DB041B_StatusRegisterRead() & 0x80));//等待擦除完毕
}

/****************************************************************************** 
描述：             
  将主存储区页存入缓冲区      
参数：                 
   buffer   - 选择BUFFER，01H选择BUFFER1，02H选择BUFFER2
  PA  - 页地址，0~2047    
******************************************************************************/
void Flash_to_buffer(unsigned char buffer, unsigned int PA) 
{
  unsigned int i = 0;
  
  while(i++ < 255) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    { 
      break;
    }
  } 
  Flash_CS_L;
  switch(buffer)
  { 
    case 1 : SPI_HostWriteByte(Main_Memory_Page_To_Buffer1_Transfer);
      break; 
    case 2 : SPI_HostWriteByte(Main_Memory_Page_To_Buffer2_Transfer);
      break; 
  }
  SPI_HostWriteByte((unsigned char)(PA >> 7)); 
  SPI_HostWriteByte((unsigned char)(PA << 1)); 
  SPI_HostWriteByte(0x00);
  Flash_CS_H;
  i = 0;
  while(!(AT45DB041B_StatusRegisterRead() & 0x80))//等待传送完毕
  {
    if(i++ > 100)
      return;
  }
}

/****************************************************************************** 
描述：             
  主存区与缓冲区内容比较        
参数：                 
   buffer   - 选择BUFFER，01H选择BUFFER1，02H选择BUFFER2
  PA  - 页地址，0~2047                
******************************************************************************/
unsigned char AT45DB041B_MainMemoryPageToBufferCompare(unsigned char buffer, unsigned int PA) 
{
  unsigned int i = 0; 
  
  while(i++ < 255) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    { 
      break;
    }
  } 
  Flash_CS_L;
  switch(buffer)
  { 
    case 1 : SPI_HostWriteByte(Main_Memory_Page_To_Buffer1_Compare);
      break; 
    case 2 : SPI_HostWriteByte(Main_Memory_Page_To_Buffer2_Compare);
      break; 
  }
  SPI_HostWriteByte((unsigned char)(PA >> 7)); 
  SPI_HostWriteByte((unsigned char)(PA << 1)); 
  SPI_HostWriteByte(0x00);
  Flash_CS_H;
  while(!(AT45DB041B_StatusRegisterRead() & 0x80));
  return(((AT45DB041B_StatusRegisterRead()& 0x40) ? 0 : 1));//返回比较结果，if StatusRegister's bit6 is 0,then match, is 1,then not match
}

/****************************************************************************** 
描述：             
        
参数：                 
   buffer  - 选择BUFFER，01H选择BUFFER1，02H选择BUFFER2
  PA  - 页地址，0~2047 
  BFA   - buffer地址，0~263
  pHeader - 待写入数据的首地址
  len   - 写入数据的长度             
******************************************************************************/
void AT45DB041B_MainMemoryPageProgramThroughBuffer(unsigned char buffer, unsigned int PA, unsigned int BFA, unsigned char *pHeader, unsigned int len) 
{ 
  unsigned int i = 0; 
  
  AT45DB041B_BufferWrite(buffer, BFA, pHeader, len); 
  
  while(i++ < 1000) 
  {
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    {
      break;
    }
  } 
  Flash_CS_L;   
  switch(buffer)
  { 
    case 1 : SPI_HostWriteByte(Main_Memory_Page_Program_Through_Buffer1);
      break; 
    case 2 : SPI_HostWriteByte(Main_Memory_Page_Program_Through_Buffer2);
      break; 
  }
  SPI_HostWriteByte((unsigned char)(PA >> 7)); 
  SPI_HostWriteByte((unsigned char)(PA << 1 | BFA >> 8)); 
  SPI_HostWriteByte((unsigned char)BFA);
  for(i = 0; i < len; i++) 
  {
    SPI_HostWriteByte(pHeader[i]);
  }
  Flash_CS_H;
}

/****************************************************************************** 
描述：             
  自动页重写         
参数：                 
   buffer  - 选择BUFFER，01H选择BUFFER1，02H选择BUFFER2
  PA  - 页地址，0~2047 
  BFA   - buffer地址，0~263
  pHeader - 待写入数据的首地址
  len   - 写入数据的长度             
******************************************************************************/
void AT45DB041B_AutoPageRewrite(unsigned char buffer, unsigned int PA) 
{
  unsigned int i = 0;
  
  Flash_to_buffer(buffer, PA);
  while(i++ < 1000) 
  { 
    if(AT45DB041B_StatusRegisterRead() & 0x80) 
    {
      break;
    }
  }
  Flash_CS_L;
  switch(buffer)
  { 
    case 1 : SPI_HostWriteByte(Auto_Page_Rewrite_With_Buffer1);
      break; 
    case 2 : SPI_HostWriteByte(Auto_Page_Rewrite_With_Buffer2);
      break; 
  }
  SPI_HostWriteByte((unsigned char)(PA >> 7)); 
  SPI_HostWriteByte((unsigned char)(PA << 1)); 
  SPI_HostWriteByte(0x00);
  Flash_CS_H;
  while(!(AT45DB041B_StatusRegisterRead() & 0x80));
} 
/*检测Falsh,成功返回1，失败返回0*/
unsigned char FindFlash(void)
{
  unsigned char temp=0;
  unsigned char i=10;                   //最大重复检测次数
  SPI_Init();
  while(i--)
  {   
    temp = AT45DB041B_StatusRegisterRead();//读出flash状态寄存器
    temp &= ~(BIT0+BIT1+BIT6);             //屏蔽无效位
    if(temp & 0X80)
      break;
  }  
  SPI_End();
  if(temp != 0X9C)  
  {
    return 0;                           //返回检测失败
  }
  return 1;                             //返回检测成功
}

